# Common Git Commands from DataCamp Course

## To check all changed files (tracked in staging area and non-tracked)
`git status`

## To compare files with last saved version:

`git diff filename`: display difference of a specific file

`git diff`: display differences of all files in staging area

`git diff directory`: display differences of files under certain directory

## To add a file to staging area (track)

`git add filename`

## To compare file with the most recent commit

`git diff -r HEAD`: compare all changed files with the "reference" as HEAD, the latest commit

`git diff -r HEAD path/to/file`: check the single file

## When opening a file with NANO editor

`Ctrl-K`: delete a line

`Ctrl-U`: un-delete a line

`Ctrl-O`: save the file

`Ctrl-X`: exit the editor

## When commiting changes in the staging area

`git commit -m "commit message"`: commit with message

`git commit --amend -m "new message"`: commit with new message

`git commit`: fire up a nano editor for commit messages

## To view a repository's history

`git log`: view commits history in the branch

`git log path`: display commits that cover changes of a specific file / directory'

## To see a list of commits in detail

`git log`

**From DataCamp**

> Every commit to a repository has a unique identifier called a **hash** (since it is generated by running the changes through a pseudo-random number generator called a hash function). This hash is normally written as a 40-character hexadecimal string like 7c35a3ce607a14953f070f0f83b5d74c2296ef93, but most of the time, you only have to give Git the first 6 or 8 characters in order to identify the commit you mean.

> Hashes are what enable Git to share data efficiently between repositories. If two files are the same, their hashes are guaranteed to be the same. Similarly, if two commits contain the same files and have the same ancestors, their hashes will be the same as well. Git can therefore tell what information needs to be saved where by comparing hashes rather than comparing entire files.

## To check out details of a specific commit

`git show hash_string_head`: Display the details of a specific commit. The details contains the commit metadadta and the diff information

> A hash is like an absolute path: it identifies a specific commit. Another way to identify a commit is to use the equivalent of a relative path. The special label `HEAD` always refers to the most recent commit. The label `HEAD~1` then refers to the commit before it, while `HEAD~2` refers to the commit before that, and so on.

> Note that the symbol between HEAD and the number is a tilde `~`, not a minus sign `-`, and that there cannot be spaces before or after the tilde.

## To check out who changes what in a file

`git annotate file`: displays commit hash, author, time, line number, and contents in the file

## To check out the difference between 2 specific commits

`git diff ID1..ID2`: shows the difference between commit with ID1 and commit with ID2

## To check out and remove untracked files

`git clean -n`: show a list of files in directory that are untracked

`git clean -f`: delete the untracked files for good

## To checkout git configurations

`git config --list` with additional options:

> To see what the settings are, you can use the command git config --list with one of three additional options:

> `--system`: settings for every user on this computer.

>`--global`: settings for every one of your projects.

>`--local`: settings for one specific project.

> Each level overrides the one above it, so **local settings (per-project)** take precedence over **global settings (per-user)**, which in turn take precedence over **system settings (for all users on the computer)**.

## To configure settings

`git config --global setting.name setting.value`: change setting on global level. setting.name is the corresponding setting you want to change, and the setting.value is the value  you want to change to


